High-level system description

Stage 7.2 — Gathering Resolution is a server-authoritative, deterministic rule resolver that runs after Stage 7.1 has identified a valid node interaction and before any inventory/reward logic exists.

It produces a single, explicit resolution result describing:

Whether the attempt is allowed (validation)

Whether it succeeded or failed (soft/hard)

Whether the attempt is permitted to grant resources and/or deplete the node

Whether a descriptive “risk” was triggered (without applying effects)

This system must be:

Deterministic (no tuning RNG at this stage)

Composable with Stage 7.1 (does not own node state)

Pure (no inventory changes, no XP, no damage)

Resolution state model
Outcomes

A gather attempt resolves to one of:

success

failure_soft (non-catastrophic; “slip / poor technique”)

failure_hard (blocked or unsafe; “instability / hazard”)

Allowed vs Not Allowed

“Not allowed” is represented via the same outcome set (typically failure_hard) plus flags:

resource_grant_allowed = false

node_depletion_allowed = false

This keeps downstream systems simple: they only need the result flags.

Risk hooks

If the node has “risk flags” (schema-defined), Stage 7.2:

surfaces which risk was triggered (descriptive only)

sets risk_triggered = true

does not apply damage, status, knockback, etc.

If multiple risk flags exist, selection must be deterministic (e.g., first by stable ordering).

Conceptual C# structures (illustrative only)

Illustrative only — not production code and not schema definitions.

// Outcome is intentionally small and explicit.
enum GatheringOutcome
{
    Success,
    FailureSoft,
    FailureHard
}

// A compact, downstream-friendly payload.
// NOTE: Risk is descriptive only at this stage.
struct GatheringResolutionResult
{
    GatheringOutcome Outcome;

    int NodeInstanceId;
    string GatheringSkillKey;        // which skill was used for this attempt (one of allowed skills)

    bool ResourceGrantAllowed;       // downstream inventory/reward systems gate on this
    bool NodeDepletionAllowed;       // Stage 7.1 node depletion gates on this
    bool RiskTriggered;

    // Optional descriptive field (if RiskTriggered==true)
    // Must be stable / deterministic if provided.
    string TriggeredRiskKeyOrFlag;   // placeholder identifier; derived from node's risk flags
}

// Inputs to the resolver are "facts", not actions.
struct GatheringAttemptContext
{
    int ServerTick;
    int PlayerId;

    int NodeInstanceId;
    string NodeTypeKey;

    bool NodeIsAvailable;
    IReadOnlyList<string> AllowedGatheringSkills;  // from schema via Stage 7.1/defs
    IReadOnlyList<string> NodeRiskFlags;           // schema-derived (exact shape is schema-owned)

    // Tool requirements are logical at this stage, not numeric.
    // Implemented via adapters so we do not invent schema fields here.
    string PlayerToolClassKey;                     // e.g., "pickaxe", "axe", etc. (placeholder concept)
}

Adapter boundaries (conceptual)

To avoid inventing schema fields, Stage 7.2 should consume node/tool/risk info through narrow interfaces:

interface INodeFactsProvider
{
    bool TryGetNodeFacts(int nodeInstanceId, out NodeFacts facts); // wraps Stage 7.1 node state + node def
}

interface IPlayerGatheringFactsProvider
{
    bool PlayerHasGatheringSkill(int playerId, string gatheringSkillKey);
    string GetEquippedToolClassKey(int playerId); // optional; can return null/empty if none
}

// Tool rules are policy-level and can be swapped without touching schemas.
interface IGatheringToolPolicy
{
    // Returns: Required / Recommended / NotApplicable
    ToolRequirementClass GetToolRequirementFor(string nodeTypeKey);
    bool ToolClassIsAcceptable(string requiredOrRecommendedToolClassKey, string playerToolClassKey);
}

enum ToolRequirementClass { NotApplicable, Recommended, Required }

Pseudocode for resolution flow

This flow assumes Stage 7.1 already performed “node exists” and “available” checks during interaction routing, but Stage 7.2 re-validates as a safety boundary.

ResolveGatherAttempt(context):

  result.NodeInstanceId = context.NodeInstanceId

  // 1) Validate node state
  if context.NodeIsAvailable == false:
      return HardNotAllowed("node_unavailable")

  // 2) Validate player has at least one allowed gathering skill for this node
  chosenSkill = SelectSkillDeterministically(context.AllowedGatheringSkills, player)
  if chosenSkill == null:
      return HardNotAllowed("missing_allowed_skill")

  result.GatheringSkillKey = chosenSkill

  // 3) Validate tool class requirements (logical, not numeric)
  toolRequirement = ToolPolicy.GetToolRequirementFor(context.NodeTypeKey)

  if toolRequirement == Required:
      if player has no tool OR tool unacceptable:
          // hard failure: blocked
          return HardNotAllowed("missing_required_tool")

  if toolRequirement == Recommended:
      if player has no tool OR tool unacceptable:
          // soft failure: allowed to try, but doesn't succeed yet
          return SoftFailNoRisk("suboptimal_tooling")

  // 4) Risk hooks (descriptive only, deterministic)
  // At this stage: no RNG. Risk triggers only via deterministic conditions.
  // Example deterministic condition: "node has risk flags AND attempt meets a fixed rule"
  // (e.g., certain node types always trigger a descriptive risk on interaction)
  risk = DetermineRiskDeterministically(context.NodeRiskFlags, context, player)

  if risk != null:
      // hard failure because risk was triggered (no effects applied here)
      return HardFailWithRisk(risk)

  // 5) Success
  return SuccessAllowed()

------------------------------------------------

HardNotAllowed(reason):
  Outcome = FailureHard
  ResourceGrantAllowed = false
  NodeDepletionAllowed = false
  RiskTriggered = false
  TriggeredRiskKeyOrFlag = reason (optional diagnostic key)
  return result

SoftFailNoRisk(reason):
  Outcome = FailureSoft
  ResourceGrantAllowed = false
  NodeDepletionAllowed = false
  RiskTriggered = false
  TriggeredRiskKeyOrFlag = reason (optional diagnostic key)
  return result

HardFailWithRisk(riskKey):
  Outcome = FailureHard
  ResourceGrantAllowed = false
  NodeDepletionAllowed = false
  RiskTriggered = true
  TriggeredRiskKeyOrFlag = riskKey
  return result

SuccessAllowed():
  Outcome = Success
  ResourceGrantAllowed = true
  NodeDepletionAllowed = true
  RiskTriggered = false
  TriggeredRiskKeyOrFlag = null
  return result

Deterministic skill selection rule

If a player has multiple allowed gathering skills, selection must be stable:

Prefer a skill explicitly supplied by the request (if present and valid), otherwise

Choose the first skill in AllowedGatheringSkills that the player possesses (stable list order)

No randomness.

Notes on future extension points (not implemented)
Probability / tuning (later)

Introduce success chance / failure rates only after schemas and balancing support numeric tuning.

Must remain server-authoritative and ideally seeded deterministically per node instance + tick if RNG is introduced.

Skill levels (later)

Replace “has skill” with:

minimum skill level gates

difficulty vs skill comparisons

tool quality modifiers

Stage 7.2 remains the correct place to compute the “success vs failure” outcome.

Yield and ResourceItem emission (later)

Replace the placeholder “resource grant allowed” with a downstream event that emits:

ResourceItem keys (and later quantities)

Stage 7.2 should not decide inventory placement; it only describes whether grant is permitted.

Persistence (later)

Stage 7.2 itself is stateless, but it can emit audit-friendly resolution records if needed (for debugging/anti-cheat).

Node state persistence remains owned by the node runtime system.

Networking (later)

Result can be serialized as a compact response:

outcome enum

node id

chosen skill key

flags

optional risk key

Client uses it for UI feedback only (no prediction).

Summary

Stage 7.2 is a pure, deterministic resolution layer that:

re-validates skill + node availability

applies simple logical tool rules (required vs recommended)

deterministically surfaces risk descriptors when applicable

returns a single GatheringResolutionResult with explicit gates for downstream systems

It intentionally avoids:

XP, yields, inventory, effects, animation timing, probability tuning, and prediction.